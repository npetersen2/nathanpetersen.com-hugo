<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Designing a Firmware Driver for Serially-Addressable LEDs for Xilinx Zynq-7000 - Nathan Petersen</title><meta name="Description" content="Project archives from Nathan Petersen over the years as he experiments and prototypes various tech-related projects."><meta property="og:title" content="Designing a Firmware Driver for Serially-Addressable LEDs for Xilinx Zynq-7000" />
<meta property="og:description" content="Tutorial covering embedded system layers and firmware design (FPGA &#43; DSP) for driving LEDs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nathanpetersen.com/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/" />
<meta property="article:published_time" content="2020-07-17T15:00:00+00:00" />
<meta property="article:modified_time" content="2020-07-17T15:00:00+00:00" /><meta property="og:site_name" content="Nathan Petersen&#39;s Blog" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Designing a Firmware Driver for Serially-Addressable LEDs for Xilinx Zynq-7000"/>
<meta name="twitter:description" content="Tutorial covering embedded system layers and firmware design (FPGA &#43; DSP) for driving LEDs."/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c">

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=1">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=1">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=1">
<link rel="manifest" href="/site.webmanifest?v=1">
<link rel="mask-icon" href="/safari-pinned-tab.svg?v=1" color="#5bbad5">
<link rel="shortcut icon" href="/favicon.ico?v=1">
<meta name="msapplication-TileColor" content="#ffc40d">
<meta name="theme-color" content="#ffffff">

<link rel="canonical" href="https://nathanpetersen.com/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/" /><link rel="prev" href="https://nathanpetersen.com/2020/05/08/simulation-of-voltage-source-inverter-induction-motor-drive/" /><link rel="next" href="https://nathanpetersen.com/2020/07/19/vanilla-challah-french-toast-la-brioche-bistro-madison-wi/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R8888Z2VZN"></script>
<script>


if (document.location.hostname.search("nathanpetersen.com") !== -1) {
    
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    
    
    
    gtag('config', 'G-R8888Z2VZN', { 'anonymize_ip': true });
}

</script><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Designing a Firmware Driver for Serially-Addressable LEDs for Xilinx Zynq-7000",
        "inLanguage": "en-us",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/nathanpetersen.com\/2020\/07\/17\/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000\/"
        },"genre": "posts","keywords": "hardware, electronics, design, firmware, leds, neopixel, ws2812, rgb, fpga, xilinx, zynq-7000, programming","wordcount":  4047 ,
        "url": "https:\/\/nathanpetersen.com\/2020\/07\/17\/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000\/","datePublished": "2020-07-17T15:00:00+00:00","dateModified": "2020-07-17T15:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Nathan Petersen"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="" data-header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Nathan Petersen"><span class="logo-light" style="display:inline;"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/n.svg"
        data-srcset="/images/n.svg, /images/n.svg 1.5x, /images/n.svg 2x"
        data-sizes="auto"
        alt="/images/n.svg"
        title="/images/n.svg" /></span><span class="logo-dark" style="display:none;"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/n-dark.svg"
        data-srcset="/images/n-dark.svg, /images/n-dark.svg 1.5x, /images/n-dark.svg 2x"
        data-sizes="auto"
        alt="/images/n-dark.svg"
        title="/images/n-dark.svg" /></span><span>Nathan Petersen</span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/bio/"> Bio </a><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/photography/"> Photography </a><a class="menu-item" href="/contact/"> Contact </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Nathan Petersen"><span class="logo-light" style="display:inline;"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/n.svg"
        data-srcset="/images/n.svg, /images/n.svg 1.5x, /images/n.svg 2x"
        data-sizes="auto"
        alt="/images/n.svg"
        title="/images/n.svg" /></span><span class="logo-dark" style="display:none;"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/n-dark.svg"
        data-srcset="/images/n-dark.svg, /images/n-dark.svg 1.5x, /images/n-dark.svg 2x"
        data-sizes="auto"
        alt="/images/n-dark.svg"
        title="/images/n-dark.svg" /></span>Nathan Petersen</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/bio/" title="">Bio</a><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/photography/" title="">Photography</a><a class="menu-item" href="/contact/" title="">Contact</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title">Designing a Firmware Driver for Serially-Addressable LEDs for Xilinx Zynq-7000</h1><div class="post-meta">
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="July 17, 2020">July 17, 2020</time><span>&nbsp;&nbsp;&middot;&nbsp;</span>
                <i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;4047 words<span>&nbsp;&nbsp;&middot;&nbsp;</span>
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;19 minutes</div>
            <div class="post-meta-line"><span class="post-category">
                        <i class="far fa-folder-open fa-fw" aria-hidden="true"></i>
                        <a href="/categories/tutorials/"></i>Tutorials</a></span><span>&nbsp;&nbsp;&middot;&nbsp;</span><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/hardware/">hardware</a>, <a href="/tags/electronics/">electronics</a>, <a href="/tags/design/">design</a>, <a href="/tags/firmware/">firmware</a>, <a href="/tags/leds/">leds</a>, <a href="/tags/neopixel/">neopixel</a>, <a href="/tags/ws2812/">ws2812</a>, <a href="/tags/rgb/">rgb</a>, <a href="/tags/fpga/">fpga</a>, <a href="/tags/xilinx/">xilinx</a>, <a href="/tags/zynq-7000/">zynq-7000</a>, <a href="/tags/programming/">programming</a></div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#system-layers">System Layers</a>
      <ul>
        <li><a href="#hardware">Hardware</a></li>
        <li><a href="#fpga">FPGA</a></li>
        <li><a href="#axi-interconnect">AXI Interconnect</a></li>
        <li><a href="#dsp">DSP</a></li>
      </ul>
    </li>
    <li><a href="#problem-statement">Problem Statement</a>
      <ul>
        <li><a href="#goal">Goal</a></li>
      </ul>
    </li>
    <li><a href="#design">Design</a>
      <ul>
        <li></li>
        <li><a href="#hardware-design">Hardware Design</a></li>
        <li><a href="#fpga-design">FPGA Design</a></li>
        <li><a href="#dsp-design">DSP Design</a></li>
      </ul>
    </li>
    <li><a href="#results">Results</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#summary">Summary</a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><strong>Ever wondered how to control serially-addressable LEDs using the Xilinx Zynq-7000 system-on-chip? Well, this tutorial is for you!</strong></p>
<p>This tutorial discusses the various embedded system layers which exist within the Xilinx Zynq-7000 SoC. It then uses these layers to craft a high-performance RGB LED driver which performs all necessary processing in the FPGA, leaving the DSP resources free for other computations. All source code is publicly available (links are given throughout the tutorial).</p>
<h2 id="introduction">Introduction</h2>
<p>Over the past few years, I have been developing an open-source control platform (both <a href="https://github.com/Severson-Group/AMDC-Hardware" target="_blank" rel="noopener noreffer">hardware</a> and <a href="https://github.com/Severson-Group/AMDC-Firmware" target="_blank" rel="noopener noreffer">firmware</a>) for research motor drives at the University of Wisconsin &ndash; Madison. I have written about the hardware a <a href="/2020/04/11/amdc-rev-d-hardware/" rel="">few</a> <a href="/2018/09/05/amdc-advanced-motor-drive-controller/" rel="">times</a> on this blog, but never the firmware. That is, until now.</p>
<p>The control platform&rsquo;s latest hardware design includes a set of four RGB LEDs. The purpose of these LEDs is to give the user the ability to easily show status information from their motor control algorithms in real-time (e.g. solid green means working, flashing red means warning, etc). During the hardware design, the specific LED type needed to be identified; serially-addressable LEDs were chosen due to the benefits described in the next section.</p>
<h4 id="serially-addressable-leds">Serially-Addressable LEDs</h4>
<p>Serially-addressable LEDs, sometimes referred to as <em>individually</em>-addressable LEDs, are smart. This means that they are not simple discrete parts which illuminate when voltage is applied to them, like normal LEDs. Serially-addressable LEDs consist of both a processor and the discrete LED technology (typically contain three LEDs: red, green, and blue (RGB)). To control the color, the user must toggle the input data pin in such a way that encodes the desired RGB output. The internal processor reads this serial stream of bits and adjusts the LED color outputs accordingly.</p>
<figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/ws2811-diagram.jpg" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/ws2811-diagram.jpg" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/ws2811-diagram.jpg" data-sub-html="<h2>Single WS2811 discrete serially-addressable RGB LED (5mm x 5mm size).</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/ws2811-diagram.jpg"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/ws2811-diagram.jpg, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/ws2811-diagram.jpg 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/ws2811-diagram.jpg 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/ws2811-diagram.jpg" width="1000" height="415" />
    </a><figcaption class="image-caption">Single WS2811 discrete serially-addressable RGB LED (5mm x 5mm size).</figcaption>
    </figure>
<p>While each device consists of both the processor and discrete RGB LEDs, I will commonly refer to the whole unit as a single LED for simplicity. Adafruit coined the term <a href="https://www.adafruit.com/category/168" target="_blank" rel="noopener noreffer">&ldquo;NeoPixel&rdquo;</a> as a general term for serially-addressable LEDs. However, there are many versions of the venerable device: <code>WS2811</code>, <code>WS2812</code>, <code>WS2812B</code>, <code>SK6812</code>, etc. These are commonly sold as strips, but also come as discrete devices; Digi-Key lists <a href="https://www.digikey.com/short/zmmvpv" target="_blank" rel="noopener noreffer">14 different</a> discrete devices! The motor drive controller hardware uses the <a href="https://www.digikey.com/product-detail/en/inolux/IN-PI556FCH/1830-1107-1-ND/7604648" target="_blank" rel="noopener noreffer"><code>IN-PI556FCH</code></a> serially-addressable LED, but they are all pretty much the same (maybe some  minor timing differences).</p>
<figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/neopixel-strip.jpg" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/neopixel-strip.jpg" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/neopixel-strip.jpg" data-sub-html="<h2>Hundreds of LEDs soldered to flexible PCB to form series strip for single-pin control.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/neopixel-strip.jpg"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/neopixel-strip.jpg, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/neopixel-strip.jpg 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/neopixel-strip.jpg 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/neopixel-strip.jpg" width="1000" height="516" />
    </a><figcaption class="image-caption">Hundreds of LEDs soldered to flexible PCB to form series strip for single-pin control.</figcaption>
    </figure>
<p>The benefit of these &ldquo;smart&rdquo; LEDs is that they can be wired together to form long chains by connecting the data output of one LED to the data input of the next. This minimizes the required processor pins needed and allows single-pin control of an arbitrary number of LEDs. For example, the motor drive controller has four RGB LEDs wired in series.</p>
<h4 id="xilinx-zynq-7000-soc">Xilinx Zynq-7000 SoC</h4>
<p>The motor drive controller uses the <a href="https://www.xilinx.com/products/silicon-devices/soc/zynq-7000.html" target="_blank" rel="noopener noreffer">Xilinx Zynq-7000</a> system-on-chip (SoC) as the main processor. This SoC is then mounted onto a <a href="http://zedboard.org/product/picozed" target="_blank" rel="noopener noreffer">system-on-module</a> (SoM) which includes the high-speed memory and power supply components. For simplicity, this tutorial will ignore the SoM and assume the LEDs are directly wired to the Zynq-7000 SoC.</p>
<p>What is the Xilinx Zynq-7000 SoC? It is a high-performance device which tightly integrates digital logic fabric (FPGA) with dual-core digital signal processors (DSP). Although it is physically <a href="https://www.digikey.com/short/zbmhmm" target="_blank" rel="noopener noreffer">one device</a>, it should be considered two devices: FPGA + DSP. These two devices just happen to be within the same physical package &ndash; this is the magic of the <em>system on chip</em>. The DSP runs C code while the FPGA implements custom digital circuitry. As seen in the diagram below, interfacing the DSP with the FPGA requires the use of AXI ports. This interface will be discussed in detail below.</p>
<figure class="image">
    <img src="images/zynq-7000-arch.svg"
         alt="Simplified view of the Zynq-7000 SoC architecture."/> <figcaption>
            <p>Simplified view of the Zynq-7000 SoC architecture.</p>
        </figcaption>
</figure>

<h2 id="system-layers">System Layers</h2>
<p>To build a high-performance firmware driver for serially-addressable LEDs, we need to understand the different embedded system layers that exist in the Zynq-7000 architecture. We will start at the lowest level (closest to hardware) and build up to the highest level (user C code).</p>
<h3 id="hardware">Hardware</h3>
<p>At the lowest level is the physical hardware. Hardware design is typically done using schematics to conceptually model how physical devices are wired together. A netlist is then created and realized on a printed circuit board (PCB). Once designed, the PCB is fabricated and assembled by soldering the electrical components into place.</p>
<p>When designing at the hardware level, consideration must be made to ensure all devices interact correctly with each other. For a reasonably slow (less than 10 MHz) digital interface consisting of a stream of bits, there is only one major concern: the voltage level must match the requirement from each device. The <code>IN-PI556FCH</code> serially-addressable LED requires 5V digital logic, so the 1.8V output from the Zynq-7000 FPGA pin must be level shifted to 5V. In addition, a power supply decoupling capacitor is used at each LED. The general hardware block diagram is shown below.</p>
<figure class="image">
    <img src="images/hardware-diagram.svg"
         alt="Block diagram of hardware required for interfacing FPGA to serially-addressable LEDs. Notice the simplicity &amp;ndash; only one FPGA pin is used to control all four LEDs."/> <figcaption>
            <p>Block diagram of hardware required for interfacing FPGA to serially-addressable LEDs. Notice the simplicity &ndash; only one FPGA pin is used to control all four LEDs.</p>
        </figcaption>
</figure>

<h3 id="fpga">FPGA</h3>
<p>One step above the physical hardware layer is the field-programmable gate array (FPGA). The FPGA lives in the realm of firmware, but is not explicitly firmware. Conceptually, FPGAs can be thought of as configurable hardware, and are sometimes referred to as &ldquo;hardware&rdquo; (e.g. &ldquo;the processing is done in hardware&rdquo; can refer to processing done in the FPGA).</p>
<p>The exact abilities of an FPGA change drastically between manufacturers and price points. At low price points, FPGAs typically have simple and limited <em>resources</em>. FPGA resources refer to the various individual digital circuit elements which can be configured to realize the user&rsquo;s desired logic, such as look-up tables (LUTs) and <a href="https://en.wikipedia.org/wiki/Flip-flop_%28electronics%29" target="_blank" rel="noopener noreffer">flip-flops</a>. These are usually combined into standard <a href="https://en.wikipedia.org/wiki/Logic_block" target="_blank" rel="noopener noreffer">logic blocks</a>. Expensive FPGAs (like the Zynq-7000 FPGA) tend to include <a href="https://www.xilinx.com/support/documentation/user_guides/ug579-ultrascale-dsp.pdf" target="_blank" rel="noopener noreffer">DSP slices</a> which can be used to implement complex math operations in parallel within the FPGA, thus speeding up the application.</p>
<p>The FPGA resources can be combined into <em>blocks / modules</em> which can implement custom user functionality. These blocks have an external interface (referred to as <em>ports</em> in hardware descriptive languages (HDL), e.g. Verilog). The ports of various FPGA blocks can be wired together to form larger blocks. <strong>However, these &ldquo;raw&rdquo; HDL block ports cannot easily connect to the DSP.</strong> To solve this and enable fast data transfer between the DSP and FPGA, Xilinx implements an industry-standard communication interface called the <em>AXI interconnect</em>.</p>
<p>In order to use this interconnect, FPGA logic blocks must be encapsulated within an <em>IP block</em>. <a href="https://www.xilinx.com/products/intellectual-property.html" target="_blank" rel="noopener noreffer">IP</a>, or Intellectual Property, is the term used to describe libraries of digital circuit design used in the FPGA fabric (note that &ldquo;IP&rdquo; is an <a href="https://en.wikipedia.org/wiki/Semiconductor_intellectual_property_core" target="_blank" rel="noopener noreffer">industry term</a>, not a Xilinx term). These libraries are generally low-level interfaces to high-performance hardware (i.e. Ethernet, DDR4 memory, PCIe, etc) which communicate with the main system processor (DSP) via the AXI interconnect.</p>
<figure class="image">
    <img src="images/ip-blocks.svg"
         alt="IP blocks interface with the main DSP using the AXI interconnect."/> <figcaption>
            <p>IP blocks interface with the main DSP using the AXI interconnect.</p>
        </figcaption>
</figure>

<p>There exist <a href="https://www.zipcores.com/" target="_blank" rel="noopener noreffer">entire</a> <a href="https://opencores.org/projects" target="_blank" rel="noopener noreffer">companies</a> who design complex IP blocks which users can buy to enhance their applications. Typically, the hardware descriptive language (HDL) which defines their inner workings is closed-source and proprietary. Xilinx also provides a library of IP that is available from within the Vivado integrated design environment (IDE).</p>
<p>Users can also <a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2013_3/ug994-vivado-ip-subsystems.pdf" target="_blank" rel="noopener noreffer">design and create</a> their own IP blocks. These blocks can implement any custom logic which the user defines. In the Zynq-7000, all IP blocks can communicate with the main DSP using the AXI interconnect. This allows C code to interact with digital logic using various interfaces, such as simple registers or complex data streaming through memory.</p>
<p>The serially-addressable LED firmware driver implements one IP block which allows the main DSP application to control the digital logic within the FPGA by writing to registers. The FPGA then updates the physical LED devices by toggle an I/O pin.</p>
<h3 id="axi-interconnect">AXI Interconnect</h3>
<p>The <a href="https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf" target="_blank" rel="noopener noreffer">AXI interconnect</a> is the bus that goes between IP cores and the main processor. AXI is part of <a href="https://en.wikipedia.org/wiki/Advanced_Microcontroller_Bus_Architecture" target="_blank" rel="noopener noreffer">ARM AMBA</a>, a family of microcontroller buses first introduced in 1996. AMBA 4.0, released in 2010, includes the second version of AXI, AXI4. Xilinx has adopted the Advanced eXtensible Interface (AXI) protocol for Intellectual Property (IP) cores.</p>
<p>There are three types of AXI4 interfaces:</p>
<ol>
<li>AXI4 — for high-performance memory-mapped requirements</li>
<li>AXI4-Lite — for simple, low-throughput memory-mapped communication (e.g., to and from control and status registers)</li>
<li>AXI4-Stream — for high-speed streaming data.</li>
</ol>
<p>The serially-addressable LED firmware driver uses <strong>AXI4-Lite</strong> since it implements a simple register interface for low-throughput RGB color data.</p>
<h3 id="dsp">DSP</h3>
<p>The highest layer in the embedded system is the user C code which runs on the digital signal processor (DSP). The C code typically implements the bulk functionality of the user application. For simple applications, <a href="https://en.wikipedia.org/wiki/Bare_machine" target="_blank" rel="noopener noreffer">bare-metal</a> programming is used (i.e. no operating system (OS)), while complex applications typically use some sort of OS (sometimes a <em>real-time</em> OS, or <a href="https://en.wikipedia.org/wiki/Real-time_operating_system" target="_blank" rel="noopener noreffer">RTOS</a>).</p>
<p>Within the application C code itself, many layers of abstraction exist. The lowest layer of C code encapsulates the hardware device <em>drivers</em>. These software drivers interface to low-level peripherals, such as status LEDs, analog inputs, or PWM outputs. They define a sensible application programming interface (API) which developers use.</p>
<p>In the Xilinx Zynq-7000 architecture, the C code drivers typically abstract away the raw interface to the FPGA IP blocks. For simple AXI4-Lite based IP, the interface is just memory-mapped writes. These writes go across the AXI interconnect and are read by the IP blocks in the FPGA. This can be thought of as simple register updates.</p>
<p>The serially-addressable LED firmware driver provides a simple C code API which developers can use to control the color and brightness of the RGB LEDs.</p>
<h2 id="problem-statement">Problem Statement</h2>
<p>Now that we understand the overall embedded system architecture and the many layers which we have to work with, let&rsquo;s start to define the problem we are trying to solve.</p>
<h3 id="goal">Goal</h3>
<p>The following list summarizes the design goals of this firmware driver:</p>
<ol>
<li>Interface with four (4) serially-addressable RGB LEDs.</li>
<li>Hide the driver implementation from the user (i.e. should be able to swap physical LEDs and update internal driver code without the user knowing).</li>
<li>Push the LED update routine into the FPGA to save DSP resources.</li>
<li>Define a simple C code API which is fast and easy-to-use.</li>
</ol>
<p>These somewhat abstract goals will result in the following C function which the user can call to update the LED colors. Note the simplicity of this interface &ndash; this completely hides <em>how</em> the LED is updated.</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="c1">// User code
</span><span class="c1">// ...
</span><span class="c1">// Set LED0 to be solid red
</span><span class="c1"></span><span class="n">led_set_color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RED</span><span class="p">);</span>
<span class="c1">// ...
</span></code></pre></div><h2 id="design">Design</h2>
<p>The design of the firmware driver will follow the diagram shown below. We only have to create the <strong>red</strong> and <strong>green</strong> blocks (C code driver and FPGA IP block). The user C code and physical hardware are out of the scope of this discussion.</p>
<figure class="image">
    <img src="images/driver-design.svg"
         alt="Full driver block diagram showing flow from user C code to hardware."/> <figcaption>
            <p>Full driver block diagram showing flow from user C code to hardware.</p>
        </figcaption>
</figure>

<h4 id="steps-per-led-update">Steps Per LED Update</h4>
<p>The following procedure outlines what happens each time the user C code wants to update the color of one of the RGB LEDs.</p>
<ol>
<li>User C code calls our C driver for desired LED update&hellip;</li>
<li>Driver sets contents of memory-mapped address&hellip;</li>
<li>Writing to this address kicks off AXI transaction (DSP to FPGA comms)&hellip;</li>
<li>Our FPGA IP block reads AXI bus write data&hellip;</li>
<li>Data processed by our digital circuitry in FPGA&hellip;</li>
<li>Starts our state machine to update LEDs&hellip;</li>
<li>State machine toggles FPGA pin correctly to communicate with LEDs&hellip;</li>
<li>LEDs process stream of bits and update their color output accordingly</li>
</ol>
<p>Based on these steps, the following sections will go through and design each part of the driver to meet the desired requirements and correct functionality.</p>
<h3 id="hardware-design">Hardware Design</h3>
<p>Since this is a tutorial on firmware design, the hardware design is out of scope. However, for completeness, an example of the hardware schematics is shown below. This simply involves connecting the serially-addressable LEDs in series to a pin on the Xilinx Zynq-7000 SoC.</p>
<figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-sch.png" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-sch.png" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-sch.png" data-sub-html="<h2>Schematics from example hardware design showing connection of LEDs.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-sch.png"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-sch.png, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-sch.png 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-sch.png 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-sch.png" width="1135" height="878" />
    </a><figcaption class="image-caption">Schematics from example hardware design showing connection of LEDs.</figcaption>
    </figure>
<h3 id="fpga-design">FPGA Design</h3>
<p>The design requirements for the firmware driver dictate that most of the processing time should be pushed into the FPGA to leave the main DSP free to do other computations. This means that the bulk of the design work will happen inside the FPGA using HDL (in this tutorial, Verilog is used).</p>
<p>The goal for this section of firmware design is to craft a complete IP block which can be integrated into the rest of the FPGA design. The IP block implementation requires two parts: 1) AXI interconnect design and 2) custom Verilog LED driver module design. These two parts are discussed below.</p>
<h4 id="axi-interface-design">AXI Interface Design</h4>
<p>The AXI interface for the IP block implements a fairly complex synchronous data transfer protocol. This means that a clock signal is used to align the data transfers between the user IP block and the main AXI bus master. The specification for this protocol is <a href="https://developer.arm.com/documentation/ihi0022/latest/" target="_blank" rel="noopener noreffer">publicly available</a>, however it is a monster to understand (the AMBA AXI spec is 273 pages long).</p>
<p>To help the reader grasp the AXI protocol, a comparison is made to the standard <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface" target="_blank" rel="noopener noreffer">SPI protocol</a>. In the simple SPI protocol, there is a clock line (<code>SCLK</code>), data line (<code>MOSI</code> and/or <code>MISO</code>), and handshaking line (<code>CS</code>). The AXI protocol implements these same basic ideas. However, the advantage of the AXI interconnect is that the <em>width</em> of the data line is much larger, which allows full 32-bit words to be transferred in one clock cycle &ndash; there are 32 physical wires between each IP block that connect to the AXI bus. Another major difference between SPI and AXI is that AXI includes address lines. This allows multiple IP blocks to share the same physical bus since the master can transmit a specific address to communicate with each IP block individually.</p>
<figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/axi-network-diagram.png" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/axi-network-diagram.png" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/axi-network-diagram.png" data-sub-html="<h2>General AXI bus diagram with multiple masters and slaves. For the Xilinx Zynq-7000 SoC, each slave represents one IP block and each master maps to one DSP.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/axi-network-diagram.png"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/axi-network-diagram.png, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/axi-network-diagram.png 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/axi-network-diagram.png 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/axi-network-diagram.png" width="1123" height="320" />
    </a><figcaption class="image-caption">General AXI bus diagram with multiple masters and slaves. For the Xilinx Zynq-7000 SoC, each slave represents one IP block and each master maps to one DSP.</figcaption>
    </figure>
<p>Each IP block must implement the required HDL for implying the digital logic of the AXI transceiver. Since this digital logic is mainly the same between all IP blocks, the Xilinx Vivado IDE includes a graphical wizard which aids the user in building a generic IP block (access this from <code>Tools</code> &gt; <code>Create and Package New IP...</code>).</p>
<h5 id="creating-ip-with-vivado">Creating IP with Vivado</h5>
<p>Depending on the application, a different variant of the AXI protocol can be used: AXI4-Lite, AXI4-Full, or AXI4-Stream. This tutorial will focus on AXI4-Lite which implements a simple register-based data transfer scheme. In the C code, the user writes / reads from a specific memory address which maps to the IP block. In the HDL, the writes update slave registers within the IP block which can then be accessed for the custom digital logic functionality. The C code can also read from the memory address which sends the IP block slave register values back to the DSP.</p>
<figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block-gen.png" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block-gen.png" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block-gen.png" data-sub-html="<h2>Vivado wizard creating AXI4-Lite IP block with 4 slave registers.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block-gen.png"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block-gen.png, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block-gen.png 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block-gen.png 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block-gen.png" width="883" height="623" />
    </a><figcaption class="image-caption">Vivado wizard creating AXI4-Lite IP block with 4 slave registers.</figcaption>
    </figure>
<p>Upon generating the IP block, the user must add it to the block diagram in Vivado. The IDE will then offer to automatically connect the new IP block to the AXI bus and DSP. Once this is complete, the IP block is ready for customization.</p>
<p>The following image shows the new IP block in the block diagram. Notice that the left side of the block contains the interface for the AXI bus &ndash; the visible black signals are the common AXI clock and reset lines. The thick blue signal, <code>S00_AXI</code>, holds all the data, address, and handshaking lines which compose the physical AXI bus. Finally, notice that there are no other I/Os from this block. At this point, the new IP block is simply a collection of four 32-bit registers that are accessible from the DSP. The next section will address how to customize the IP block with the required LED driver functionality.</p>
<figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block1.png" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block1.png" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block1.png" data-sub-html="<h2>New IP block as seen in Vivado block diagram after connection to AXI interconnect.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block1.png"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block1.png, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block1.png 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block1.png 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/vivado-ip-block1.png" width="584" height="392" />
    </a><figcaption class="image-caption">New IP block as seen in Vivado block diagram after connection to AXI interconnect.</figcaption>
    </figure>
<h4 id="custom-led-driver-design">Custom LED Driver Design</h4>
<p>Now that an &ldquo;empty&rdquo; IP block is created, the user needs to update it to implement the FPGA application-specific functionality. For this tutorial, each IP block slave register will hold the color state for one RGB LED. Since there are four slave registers and four physical LEDs, this works perfectly.</p>
<p>According to the <a href="http://www.inolux-corp.com/datasheet/SMDLED/Addressable%20LED/IN-PI556FCH.pdf" target="_blank" rel="noopener noreffer">LED datasheet</a>, each LED requires 24 bits of data which encode the desired color output. Since the LEDs are wired in series, once the first LED receives its color data, it latches it in and then forwards all future data down the line to the next LED.</p>
<p>Since the LEDs communicate using a single data wire (no clock line), specific physical bit patterns are used to encode a logical color data bit (1 or 0). The physical patterns use varying bit widths so that the LEDs can determine the data bit value. All serially-addressable LEDs work like this, but the exact timing varies between manufacturers. The following datasheet excerpt explains how to send a single bit of data to the LEDs.</p>
<figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-bit-timing-diagram.png" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-bit-timing-diagram.png" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-bit-timing-diagram.png" data-sub-html="<h2>LED bit timing diagram with required bit width specifications.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-bit-timing-diagram.png"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-bit-timing-diagram.png, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-bit-timing-diagram.png 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-bit-timing-diagram.png 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-bit-timing-diagram.png" width="808" height="849" />
    </a><figcaption class="image-caption">LED bit timing diagram with required bit width specifications.</figcaption>
    </figure>
<p>The above diagram shows how to send a single bit to the LEDs. However, the color data is 24 bits long. To send all the color data bits, the FPGA driver should iterate over each bit from the slave registers and create the correct bit pattern, following the above diagrams. The order of the color data bits is presented in the datasheet, with the relevant excerpt shown below.</p>
<figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-rgb-data-diagram.png" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-rgb-data-diagram.png" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-rgb-data-diagram.png" data-sub-html="<h2>LED RGB data format specification.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-rgb-data-diagram.png"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-rgb-data-diagram.png, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-rgb-data-diagram.png 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-rgb-data-diagram.png 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/led-rgb-data-diagram.png" width="1549" height="705" />
    </a><figcaption class="image-caption">LED RGB data format specification.</figcaption>
    </figure>
<p>Data is transmitted MSB first and in the following order: green then red then blue. After all the color data bits are sent for a single LED, the <code>RESET</code> pattern is sent which causes the LED to latch in the bits. From then on, the LED will forward new data bits to the next LED in the sequence.</p>
<h5 id="verilog-modules">Verilog Modules</h5>
<p>For this example tutorial, two Verilog modules are created to drive the LEDs: <code>drv_INPI556FCH.v</code> and <code>line_driver.v</code>. The <code>line_driver</code> block is the low-level module responsible for creating the specific bit patterns as defined in the datasheet. The <code>drv_INPI556FCH</code> block iterates over all the IP slave register color data bits and uses the <code>line_driver</code> to send them across the line.</p>
<p>Source code for these modules is freely available:</p>
<ul>
<li><a href="https://github.com/Severson-Group/AMDC-Firmware/blob/develop/ip_repo/amdc_leds_1.0/src/line_driver.v" target="_blank" rel="noopener noreffer"><code>line_driver.v</code></a></li>
<li><a href="https://github.com/Severson-Group/AMDC-Firmware/blob/develop/ip_repo/amdc_leds_1.0/src/drv_INPI556FCH.v" target="_blank" rel="noopener noreffer"><code>drv_INPI556FCH.v</code></a></li>
</ul>
<h4 id="axi--custom-hdl-integration">AXI / Custom HDL Integration</h4>
<p>Once both the AXI bus interface is written (or generated) and the custom HDL modules are finished, they must be integrated together. This logic is usually written at the bottom of the auto-generated AXI implementation file (<code>/hdl/my_ip_block_v1_0_S00_AXI.v</code>). To drive the four RGB LEDs, a state machine is used to iterate across all four IP slave registers. For each register, the color data is transmitted to the LEDs using the <code>drv_INPI556FCH</code> module. The <code>RESET</code> bit pattern is sent between each LED&rsquo;s color data.</p>
<p>The firmware driver is designed such that the C code <strong>does not</strong> have to manually trigger the update event to the LEDs. The driver is &ldquo;smart&rdquo; &ndash; when the IP slave registers are updated, this triggers the transmission automatically. The AXI signal <code>slv_reg_wren</code> is used to detect the update event.</p>
<p>The full integration code can be read <a href="https://github.com/Severson-Group/AMDC-Firmware/blob/v1.0.0/ip_repo/amdc_leds_1.0/hdl/amdc_leds_v1_0_S00_AXI.v#L400" target="_blank" rel="noopener noreffer">here</a>. Note that the first half of the file contains the AXI transceiver implementation and the second half integrates the AXI slave registers with the custom HDL blocks.</p>
<h3 id="dsp-design">DSP Design</h3>
<p>Since the firmware driver was crafted where the majority of the LED update computation occurs in the FPGA, the required actions in the DSP are very minimal. The DSP must simply write the proper LED color data to the IP slave registers. When new color data arrives in the slave registers, the IP block automatically streams this data out to the LEDs.</p>
<p>Since the IP block is based around the AXI4-Lite system, writing to the IP slave registers from the DSP is as easy as writing to a memory address. The IP block is referred to as a <em>memory-mapped peripheral</em>.</p>
<p>Each IP block in Vivado is assigned a base address. This address is used to write to the IP slave registers. For example, the RGB LED driver IP base address is <code>0x43C30000</code>. Xilinx provides utility functions that safely read and write from the memory-mapped peripherals:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="c1">// Write to IP slave register
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">Xil_Out32</span><span class="p">(</span><span class="n">uintptr_t</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">Value</span><span class="p">);</span>

<span class="c1">// Read from IP slave register
</span><span class="c1"></span><span class="n">uint32_t</span> <span class="nf">Xil_In32</span><span class="p">(</span><span class="n">uintptr_t</span> <span class="n">Addr</span><span class="p">);</span>
</code></pre></div><p>For this application, we only need to write to the registers, not read. To write to the registers, an offset is added to the base address. An offset of zero corresponds to the first slave register. Note that the offset is in bytes and since each register is 4 bytes long (32 bits), the second register is located at <code>BASE_ADDR + 4</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">led_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">color</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Xil_Out32</span><span class="p">(</span><span class="n">BASE_ADDR</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="n">color</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>The example C code driver for the RGB LEDs provides some higher-level functionality to the user. It abstracts away the specific bit ordering for the IP slave registers and allows the user to set the colors based on a <code>color_t</code> typedef.</p>
<p>Source code for the C code driver interface is freely available:</p>
<ul>
<li><a href="https://github.com/Severson-Group/AMDC-Firmware/blob/develop/sdk/app_cpu1/common/drv/led.h" target="_blank" rel="noopener noreffer"><code>drv/led.h</code></a></li>
<li><a href="https://github.com/Severson-Group/AMDC-Firmware/blob/develop/sdk/app_cpu1/common/drv/led.c" target="_blank" rel="noopener noreffer"><code>drv/led.c</code></a></li>
</ul>
<h2 id="results">Results</h2>
<p>Now that all the driver firmware is written, it needs to be exercised to show that it actually works. The driver code lives in the background as compared to the user C code. The user C code uses the API provided by the <code>drv/led.h</code> file to control the RGB LEDs.</p>
<h4 id="static-rgb-colors">Static RGB Colors</h4>
<p>The driver can be used to set static colors to each LED individually, as seen below. This is accomplished using the following pseudo-code:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="n">led_set_color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RED</span><span class="p">);</span>
<span class="n">led_set_color</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GREEN</span><span class="p">);</span>
<span class="n">led_set_color</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">);</span>
<span class="n">led_set_color</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">WHITE</span><span class="p">);</span>
</code></pre></div><figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on1.jpg" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on1.jpg" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on1.jpg" data-sub-html="<h2>Static red, green, blue, and white color outputs.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on1.jpg"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on1.jpg, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on1.jpg 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on1.jpg 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on1.jpg" width="1000" height="750" />
    </a><figcaption class="image-caption">Static red, green, blue, and white color outputs.</figcaption>
    </figure>
<figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on2.jpg" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on2.jpg" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on2.jpg" data-sub-html="<h2>Combining red, green, and blue to form new colors.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on2.jpg"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on2.jpg, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on2.jpg 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on2.jpg 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-led-on2.jpg" width="1000" height="750" />
    </a><figcaption class="image-caption">Combining red, green, and blue to form new colors.</figcaption>
    </figure>
<h4 id="real-time-animation">Real-Time Animation</h4>
<p>The user can also create animations using the driver. The following pseudo-code implements an example animation where each LED is illuminated one-by-one in a color chasing manner. Various colors are used throughout the animation.</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="n">color_t</span> <span class="n">colors</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">RED</span><span class="p">,</span> <span class="n">GREEN</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">,</span> <span class="n">WHITE</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Callback function which updates LEDs
</span><span class="c1">// (called at 5 Hz)
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">example_callback</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">led_set_color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">colors</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]);</span>
   <span class="n">led_set_color</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">colors</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]);</span>
   <span class="n">led_set_color</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">colors</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]);</span>
   <span class="n">led_set_color</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">colors</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]);</span>

   <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><figure><a class="lightgallery" href="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-animation.gif" title="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-animation.gif" data-thumbnail="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-animation.gif" data-sub-html="<h2>Toggling RGB LEDs through animation to exercise firmware driver.</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-animation.gif"
            data-srcset="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-animation.gif, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-animation.gif 1.5x, /2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-animation.gif 2x"
            data-sizes="auto"
            alt="/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/images/rgb-leds-animation.gif" width="600" height="338" />
    </a><figcaption class="image-caption">Toggling RGB LEDs through animation to exercise firmware driver.</figcaption>
    </figure>
<h2 id="summary">Summary</h2>
<p>This tutorial described the different layers of embedded systems, specifically related to the Xilinx Zynq-7000 SoC architecture. These layers were then used to craft a high-performance firmware driver to control serially-addressable RGB LEDs on an example hardware platform. By understanding the layers of the embedded system, the firmware driver managed to push the LED update overhead into the FPGA, thus not blocking the DSP from running code.</p>
<h4 id="working-firmware-links">Working Firmware Links</h4>
<p>The code in this tutorial is fairly piecemeal, i.e. the reader cannot directly compile and run it. However, the complete <strong>working</strong> <a href="https://github.com/Severson-Group/AMDC-Hardware" target="_blank" rel="noopener noreffer">hardware</a> and <a href="https://github.com/Severson-Group/AMDC-Firmware" target="_blank" rel="noopener noreffer">firmware</a> design for this example driver is open-source and available on GitHub. The hardware schematics are available <a href="https://github.com/Severson-Group/AMDC-Hardware/blob/develop/REV20200129D/AMDC_v4_sch.pdf" target="_blank" rel="noopener noreffer">here</a> (see page 11 for RGB LEDs). The IP block design can be found <a href="https://github.com/Severson-Group/AMDC-Firmware/tree/v1.0.0/ip_repo/amdc_leds_1.0" target="_blank" rel="noopener noreffer">here</a> with the custom FPGA HDL blocks located <a href="https://github.com/Severson-Group/AMDC-Firmware/tree/v1.0.0/ip_repo/amdc_leds_1.0/src" target="_blank" rel="noopener noreffer">here</a>. The C driver code for this IP block is located <a href="https://github.com/Severson-Group/AMDC-Firmware/blob/v1.0.0/sdk/app_cpu1/common/drv/led.c" target="_blank" rel="noopener noreffer">here</a>.</p>
<hr>
<h4 id="new-post-notifications">New Post Notifications</h4>
<p>If you read this far, you might be interested in subscribing for email notifications about future new posts I write. I will never spam you! Every few months, I write a new article for this website, and will send you email about it. You can unsubscribe at any time. Thank you.</p>


<link href="//cdn-images.mailchimp.com/embedcode/slim-10_7.css" rel="stylesheet" type="text/css">
<style type="text/css">
#mc_embed_signup{background:transparent;clear:left;font:14px Helvetica,Arial,sans-serif}
#mc_embed_signup form{padding:0}
</style>

<div id="mc_embed_signup">
    <form action="https://nathanpetersen.us19.list-manage.com/subscribe/post?u=0683969232247313b7dd19933&amp;id=6ae23be408" method="post" id="mc-embedded-subscribe-form">
        <div id="mc_embed_signup_scroll">
            <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
            
            <div style="position: absolute; left: -5000px;"aria-hidden="true"><input type="text"name="b_0683969232247313b7dd19933_6ae23be408"tabindex="-1"value=""></div>
        
            <div class="clear">
                <input type="submit"value="Subscribe"name="subscribe"id="mc-embedded-subscribe"class="button">
            </div>
        </div>
    </form>
</div>


</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://nathanpetersen.com/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/" data-title="Designing a Firmware Driver for Serially-Addressable LEDs for Xilinx Zynq-7000" data-hashtags="hardware,electronics,design,firmware,leds,neopixel,ws2812,rgb,fpga,xilinx,zynq-7000,programming"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://nathanpetersen.com/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/" data-hashtag="hardware"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://nathanpetersen.com/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/" data-title="Designing a Firmware Driver for Serially-Addressable LEDs for Xilinx Zynq-7000"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://nathanpetersen.com/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/" data-title="Designing a Firmware Driver for Serially-Addressable LEDs for Xilinx Zynq-7000"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://nathanpetersen.com/2020/07/17/designing-a-firmware-driver-for-serially-addressable-leds-for-xilinx-zynq-7000/" data-title="Designing a Firmware Driver for Serially-Addressable LEDs for Xilinx Zynq-7000"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/hardware/">hardware</a>, <a href="/tags/electronics/">electronics</a>, <a href="/tags/design/">design</a>, <a href="/tags/firmware/">firmware</a>, <a href="/tags/leds/">leds</a>, <a href="/tags/neopixel/">neopixel</a>, <a href="/tags/ws2812/">ws2812</a>, <a href="/tags/rgb/">rgb</a>, <a href="/tags/fpga/">fpga</a>, <a href="/tags/xilinx/">xilinx</a>, <a href="/tags/zynq-7000/">zynq-7000</a>, <a href="/tags/programming/">programming</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2020/05/08/simulation-of-voltage-source-inverter-induction-motor-drive/" class="prev" rel="prev" title="Simulation of Voltage Source Inverter Induction Motor Drive"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Simulation of Voltage Source Inverter Induction Motor Drive</a>
            <a href="/2020/07/19/vanilla-challah-french-toast-la-brioche-bistro-madison-wi/" class="next" rel="next" title="Vanilla Challah French Toast - La Brioche Bistro - Madison, WI">Vanilla Challah French Toast - La Brioche Bistro - Madison, WI<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2016 &ndash; 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://nathanpetersen.com/" target="_blank">Nathan Petersen</a></span></div>
            <div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><span class="license">Content is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="license noopener noreferrer">CC BY-NC-SA 4.0</a> unless indicated.</span><span class="google-analytics-tracking-info">
                    This page uses <a href="https://analytics.google.com/">Google Analytics</a> to collect <b>anonymous</b> statistics.
                </span>
                <small>Read the <a href="/privacy/">Privacy Policy</a></small>
            </div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
